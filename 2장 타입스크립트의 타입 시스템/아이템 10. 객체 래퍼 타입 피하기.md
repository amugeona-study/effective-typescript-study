## 객체 래퍼 타입 피하기

자바스크립트는 객체 이외에도 기본형 값들에 대한 일곱 가지 타입(`string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`)가 있다.  
기본형들은 불변(immutable)이며, 메서드를 가지지 않는다는 점에서 객체와 구분된다. 그런데 기본형인 `string`의 경우 `charAt`과 같이 메서드를 가지고 있는 것처럼 보인다.  

하지만 사실 `charAt`은 `string`의 메서드가 아니며, `string`을 사용할 때 자바스크립트 내부적으로 많은 동작이 일어난다. `string` '기본형'에는 메서드가 없지만, 자바스크립트에는 메서드를 가지는 `String` '객체' 타입이 정의되어 있다.  

자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환한다. `string` 기본형에 `charAt`같은 메서드를 사용할 때, 자바스크립트는 기본형을 `String` 객체로 래핑하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버린다.  

만약 `String.prototype`을 몽키-패치(_런타임에 프로그램의 어떤 기능을 수정해서 사용하는 기법: 자바스크립트에서는 주로 프로토타입 변경_) 한다면 앞서 설명한 내부적인 동작들을 관찰할 수 있다.

```ts
// Don't do this!
const originalCharAt = String.prototype.charAt;
String.prototype.charAt = function(pos) {
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
};
console.log('primitive'.charAt(3));
```
해당 코드의 결과값으로
```text
[String: 'primitive'] 'object' 3
m
```
이 나오는 것을 볼 수 있다.  

메서드 내의 `this`는 `string` 기본형이 아닌 `String` 객체 래퍼로, `String` 객체를 직접 생성할 수도 있으며, `string` 기본형처럼 동작한다. 하지만 `string` 기본형과 `String` 객체 래퍼가 항상 동일하게 동작하는 것은 아니다. 예를 들어, `String` 객체는 오직 자기 자신과만 동일하다.  
```text
> "hello" === new String("hello")
false
```
객체 래퍼 타입의 자동 변환은 종종 당황스러운 동작을 보일 때가 있다. 예를 들어, 어떤 속성을 기본형에 할당한다면 그 속성이 사리진다.
```text
> x = "hello"
> x.language = 'English'
'English'
> x.language
undefined
```
실제로는 `x`가 `String` 객체로 변환된 후 `language` 속성이 추가되었고, `language` 속성이 추가된 객체는 버려진 것이다.  

다른 기본형에도 동일하게 객체 래퍼 타입이 존재한다. `number`에는 `Number`, `boolean`에는 `Boolean`, `symbol`에는 `Symbol`, `bigint`에는 `BigInt`가 존재한다. (`null`과 `undefined`에는 객체 래퍼가 존재하지 않는다.)  
이 래퍼 타입들 덕분에 기본형 값에 메서드를 사용할 수 있고, 정적 메서드(`String.fromCharCode` 등 ..)도 사용할 수 있다. 그러나 보통은 래퍼 객체를 직접 생성할 필요가 없다.  

타입스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링한다.  
그런데 `string`을 사용할 때는 특히 유의해야 한다. `string`을 `String`으로 잘못 타이핑하기 쉽고, 실수를 하더라도 처음에는 잘 동작하는 것처럼 보이기 때문이다.  
```ts
function getStringLen(foo: String) {
  return foo.length;
}

getStringLen("hello");  // OK
getStringLen(new String("hello"));  // OK
```
그러나 `string`을 매개변수로 받는 메서드에 `String` 객체를 전달하는 순간 문제가 발생한다.  
```ts
function isGreeting(phrase: String) {
  return ['hello', 'good day'].includes(phrase);
  //                                    ~~~~~~
  // Argument of type 'String' is not assignable to parameter of type 'string'.
  // 'string' is a primitive, but 'String' is a wrapper object.
  // Prefer using 'string' when possible.
}
```
`string`은 `String`에 할당할 수 있지만 `String`은 `string`에 할당할 수 없기 때문이다.  
```ts
const s: String = "primitive";
const n: Number = 12;
const b: Boolean = true;
```
다음과 같이 타입을 선언하고 기본형 타입을 객체 래퍼에 할당할 수는 있지만, 기본형 타입을 객체 래퍼에 할당하는 것은 오해하기 쉽고, 굳이 그렇게 할 필요도 없다. 그렇기 때문에 그냥 기본형 타입을 사용하는 것이 낫다.  

그런데, `new` 없이 `BigInt`와 `Symbol`을 호출하는 경우는 기본형을 생성하기 때문에 사용해도 된다. 이들은 `bigInt`와 `symbol` 값이지만 타입스크립트 타입은 아니다. (아이템 8 참고: 값 공간에서의 `typeof` - 대상 심벌의 런타임 타입을 가리키는 문자열 반환, 타입스크립트 타입과는 다르다.)
```text
> typeof BigInt(1234)
"bigint"
> typeof Symbol('sym')
"symbol"
```

---
### 요약
* 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 한다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다.
* 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 한다.