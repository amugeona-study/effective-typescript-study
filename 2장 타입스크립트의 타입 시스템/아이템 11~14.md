# 2장 타입스크립트의 타입시스템

## 아이템 11 잉여 속성 체크의 한계 인지하기

---

### 잉여 속성 체크

- 타입이 명시된 변수에 **객체 리터럴을 할당**할 때, **해당 타입의 속성이 있는지** 그리고 **'그 외 속성은 없는지'** 확인

```tsx
interface Room {
 numDoors: number;
 ceilingHeightFt: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present'
// ~~ 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Room' 형식에 'elephant'이(가) 없습니다.
} // 잉여 속성 체크 실행
```

- 구조적 타이핑 관점에서 생각해 보면 r은 Room 타입의 속성을 모두 가지고 있으므로 오류가 발생하지 않아야 함
- 잉여 속성 체크가 실행되는 경우 오류 발생

### 잉여 속성 체크를 하지 않는 경우

- 객체 리터럴이 아닌 경우
    
    ```tsx
    const obj = {
    	numDoors: 1,
      ceilingHeightFt: 10,
      elephant: 'present'
    }
    
    const r: Room = obj; // 정상(구조적 타이핑)
    ```
    
- 타입 단언문을 사용하는 경우

### 요약

- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행됨
- 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다름. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일번적인 구조적 할당 가능성 체크를 구분할 수 있음
- 잉여 속성 체크에는 한계가 있음. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있음

## 아이템 12 함수 표현식에 타입 적용하기

---

- 자바스크립트와 타입스크립트에서는 함수 문장과 표현식을 다르게 인식

```tsx
function rollDice1(sides) { /* ... */ } // 문장
const rollDice2 = function(sides) { /* ... */ }; // 표현식
const rollDice3 = (sides) => { /* ... */ }; // 표현식
```

- 타입스크립트에서는 함수 표현식을 사용하는 것이 좋음
    - 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선어하여 함수 표현식에 재사용할 수 있기 때문
- 함수 타입의 선언은 불필요한 코드의 반복을 줄임
    
    ```tsx
    type BinaryFn = (a: number, b: number) => number;
    const add: BinaryFn = (a, b) => a + b;
    const sub: BinaryFn = (a, b) => a - b;
    const mul: BinaryFn = (a, b) => a * b;
    const div: BinaryFn = (a, b) => a / b;
    
    // 함수 타입 선언으로 매번 (a: number, b: number) 적어 주지 않아도 됨
    ```
    

### 요약

- 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋음
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 해야 함. 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 함
- 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 됨

## 아이템 13 타입과 인터페이스의 차이점 알기

---

- 타입스크립트에서 명명된 타입을 정의하는 방법
    - 타입을 사용하는 방법
        
        ```tsx
        type TState = {
          name: string;
          capital: string;
        }묘
        ```
        
    - 인터페이스를 사용하는 방법
        
        ```tsx
        interface IState {
          name: string;
          capital: string;
        }
        ```
        
- 대부분의 경우에는 타입을 사용해도 되고 인터페이스를 사용해도 됨
- **타입과 인터페이스 사이에 존재하는 차이를 분명하게 인식함으로써** 같은 상황에서 동일한 방법으로 명명된 타입을 정의해 **코드의 일관성을 유지**할 수 있도록 해야 함

### 인터페이스 선언과 타입 선언의 비슷한 점

- 명명된 타입은 인터페이스/타입 중 무엇을 사용하든 상태에 차이가 없고, 동일한 오류가 발생함
- 인덱스 시그니처는 인터페이스/타입 모두 사용 가능
- 함수 타입도 인터페이스/타입 모두 정의 가능
- 제너릭도 인터페이스/타입 모두 가능
- 인터페이스는 타입을 확장할 수 있으며, 타입은 인터페이스를 확장할 수 있음
- 클래스를 구현(implements)할 수 있음

### 인터페이스 선언과 타입 선언의 다른 점

- 유니온 타입은 존재하지만 유니온 인터페이스는 존재하지 않음
- 인터페이스는 타입을 확장할 수 있지만, 인터페이스의 프로퍼티의 타입 중 유니온 타입은 확장할 수 없음
- 튜플과 같은 배열 타입을 타입/인터페이스로 선언할 수 있지만, 인터페이스로 선언한 튜플 타입은 배열에서 사용할 수 있는 `concat` 같은 메서드를 사용할 수 없음 → 튜플은 `type` 키워드로 구현하는 것이 좋음
- 인터페이스에서만 타입을 보강할 수 있음
    
    ```tsx
    // 이 예제처럼 속성을 확장하는 것을 선언 병합(declaration merging)이라고 한다.
    interface IState {
      name: string;
      capital: string;
    }
    interface IState {
      population: number;
    }
    const wyoming: IState = {
      name: 'Wyoming',
      capital: 'Cheyenne',
      population: 500_000
    };  // OK
    ```
    

### 타입 vs 인터페이스

- 복잡한 타입 → 타입 별칭
- 두 가지 방법으로 모두 표현할 수 있는 객체 타입인 경우
    - 프로젝트에서 일관되게 타입을 사용한다면 타입, 인터페이스를 사용한다면 인터페이스 사용
    - 아직 스타일이 확립되지 않은 프로젝트라면 향후 보강의 가능성을 열어 둘 것
        - API에 대한 타입 선언 시 인터페이스를 사용하는 것이 좋음
    - 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계임 → 타입 사용

### 요약

- 타입과 인터페이스의 차이점과 비슷한 점을 이해해야 함
- 한 타입을 type과 interface 두 가지 문법을 사용해서 작성하는 방법을 터득해야 함
- 프로젝트에서 어떤 문법을 사용할지 결정할 때 한 가지 일관된 스타일을 확립하고 보강 기법이 필요한지 고려해야 함

## 아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기

---

- 타입 간에 매핑을 통해 타입 정의에서도 DRY(Don't Repeat Yourself)의 장점을 적용할 수 있음

### 타입에 이름 붙이기

- 반복적으로 등장하는 타입에 이름을 붙이기

```tsx
function distance(a: { x: number; y: number }, b: { x: number; y: number }) {
  // 중복되는 부분을 이름을 붙인다.
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

interface Point2D {
  x: number;
  y: number;
}
function distance(a: Point2D, b: Point2D) {
  /* ... */
}
```

- 함수 두 개의 공통 타입을 뽑아 적용하는 경우

```tsx
interface Options {}

function get(url: string, opts: Options): Promise<Response> {
  return Promise.resolve(new Response());
}
function post(url: string, opts: Options): Promise<Response> {
  return Promise.resolve(new Response());
}

// 함수 표현식으로 바꾸기
type HTTPFunction = (url: string, options: Options) => Promise<Response>;
const get: HTTPFunction = (url, options) => {
  return Promise.resolve(new Response());
};
const post: HTTPFunction = (url, options) => {
  return Promise.resolve(new Response());
};
```

### **키 매핑**

- 확장에는 extends와 &(인터섹션) 사용 가능
- 인터섹션은 일반적이지 않은 방법
- **문제 1**

```tsx
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

interface TopNavState {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
}

// 1. 이 방법보다
interface State extends TopNavState {
  pageContents: string;
}

// 2. 부분집합을 사용하는 방법이 더 나음
// 전체 앱을 하나의 인터페이스로 유지할 수 있게 해 줌
type TopNavState = {
  userId: State['userId'];
  pageTitle: State['pageTitle'];
  recentFiles: State['recentFiles'];
};

// 3. State[’...’]  중복 제거
type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]; // 인덱스 시그니처 사용을 위해 interface 에서 type으로 변경
};

// 3-1. Pick 사용
type TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>;
```

- **문제 2**

```tsx
//  ActionType을 키매핑으로 수정해 보기
interface SaveAction {
  type: 'save';
  // ...
}
interface LoadAction {
  type: 'load';
  // ...
}

type Action = SaveAction | LoadAction;

type ActionType = 'save' | 'load'; // x 중복됨

type ActionType = Action['type']; // 정답

type ActionRec = Pick<Action, 'type'>; // 객체로 잡아내서 오답 {type: "save" | "load"}
```

- **문제 3**

```tsx
// OptionsUpdate를 키 매핑으로 만들어 보기
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
interface OptionsUpdate {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}

type OptionsUpdate = { [k in keyof Options] ?: Options[k] }; // 정답
```

- 문제 4

```tsx
// 값의 형태에 해당하는 타입을 정의하고 싶은 경우

const INIT_OPTIONS = {
	width: 640,
	height: 480,
	color: '#00FF00',
	label: 'VGA'
}

type Options = typeof INIT_OPTIONS // 정답
```

### **제너릭 타입**

- 제너릭 타입은 타입을 위한 함수
    - 제너릭 타입에서 매개변수를 제한할 수 있는 방법이 필요함
    - 제너릭 타입에서 매개변수를 제한할 수 있는 방법은 extends를 사용하는 것
- 타입스크립트가 제너릭 매개변수의 타입을 추론하게 하기 위해, 함수를 작성할 때 신중하게 타입을 고려해야함
- Pick함수에서 K는 범위가 너무 넓음
    - K는 실제로 T의 키의 부분집합(keyof T)가 되어야
    - 타입이 값의 집합이라는 관점에서 생각하면 extends가 확장이 아닌 부분집합

```tsx
type Pick<T, K>  = {[k in K]: T[k]}; // 오류

type Pick<T, K extends keyof T> = {[k in K]: T[k]}; // 정상
```

- 목표는 유효한 프로그램은 통과시키고 무효한 프로그램에는 오류를 발생시키는 것.

### 요약

- DRY(don’t repeat yourself) 원칙을 타입에도 최대한 적용해야 함
- 타입에 이름을 붙여서 반복을 피해야 함. extends를 사용해서 인터페이스 필드의 반복을 피해야 함
- 타입들 간의 매핑을 위해 타입스크립트가 제공한 도구들을 공부하면 좋음(keyof, typeof, 인덱싱, 매핑된 타입 포함)
- 제너릭 타입은 타입을 위한 함수와 같음 타입을 반복하는 대신 제너릭 타입을 사용해 타입들 간에 매핑을 하는 것이 좋음. 제너릭 타입을 제한하려면 extends를 사용하면 됨
- 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 함