## 타입이 값들의 집합이라고 생각하기

런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가진다.  
그러나 코드가 실행되기 전, 즉 타입스크립트가 오류를 체크하는 순간에는 **타입**을 가지고 있다. 타입은 **할당 가능한 값들의 집합**이다. 예를 들어, 모든 숫자값의 집합을 `number` 타입이라고 할 때, `42` 와 `37.25` 는 이에 해당되지만, `'Canada'` 는 그렇지 않다. `null` 과 `undefined` 는 `strictNullChecks` 여부에 따라 해당될 수도, 아닐 수도 있다.  

가장 작은 집합은 아무것도 포함하지 않는 공집합이며, 타입스크립트에서는 `never` 타입이다. `never` 타입으로 선언된 변수의 범위는 공집합이기 때문에, 아무런 값도 할당할 수 없다.  
``` ts
const x: never = 12;
//    ~ Type 'number' is not assignable to type 'never'.
```

그 다음으로 작은 집합은 한 가지 값만 포함하는 타입이다. 이들은 유닛(`unit`) 타입으로 불리는 리터럴(`literal`) 타입이다.  
``` ts
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개, 혹은 여러 타입을 묶으려면 유니온(`union`) 타입을 사용한다.  
``` ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

다양한 타입스크립트 오류에서 '할당 가능한' 이라는 문구를 볼 수 있는데, 이러한 문구는 집합의 관점에서 원소(값-타입의 관계) 혹은 부분집합(타입-타입의 관계)을 의미한다.  
```ts
const a: AB = 'A';  // OK, value 'A' is a member of the set {'A', 'B'}
const c: AB = 'C';
//    ~ Type '"C"' is not assignable to type 'AB'
```
`"C"` 는 유닛 타입이며, 단일 값으로 이루어져 있고 타입 `AB` 의 부분집합이 아니므로 오류가 발생한다. 즉, 집합의 관점에서 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이라고 볼 수 있다.  

``` ts
// OK, {"A", "B"} is a subset of {"A", "B"}:
const ab: AB = Math.random() < 0.5 ? 'A' : 'B';
const ab12: AB12 = ab;  // OK, {"A", "B"} is a subset of {"A", "B", 12}

declare let twelve: AB12;
const back: AB = twelve;
//    ~~~~ Type 'AB12' is not assignable to type 'AB'
//           Type '12' is not assignable to type 'AB'
```

위 코드의 타입들은 집합의 범위가 한정되어 있기 때문에 쉽게 이해할 수 있지만, 실제 다루게 되는 타입은 대부분 범위가 무한대이기 때문에 어렵게 느껴질 수 있다.  

<br/>

``` ts
interface Identified {
  id: string;
}
```
위 인터페이스가 타입 범위 내의 값들에 대한 설명이라고 생각해보면, 어떤 객체가 `string` 으로 할당 간으한 `id` 속성을 가지고 있다면 그 객체는 `Identified` 이다.  

아이템 4에서 설명했듯이, **구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음**을 의미한다. 심지어 **함수 호출의 매개변수에서도 다른 속성을 가질 수 있다**. 이러한 사실은 특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크(`excess property checking`) 만 생각하다 보면 간과하기 쉽다.  

연산과 관련된 이해를 돕기 위해 값의 집합을 타입이라고 생각해보자.  
``` ts
interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person & Lifespan;
```

`&` 연산자는 두 타입의 인터섹션(`intersection`, 교집합)을 계산한다. `Person` 과 `Lifespan` 인터페이스는 공통으로 가지는 속성이 없기 때문에 `PersonSpan` 타입을 공집합(`never` 타입)으로 예상하기 쉽지만, **타입 연산자는 인터페이스의 속성이 아닌, 값의 집합(타입의 범위)에 적용**된다. 그리고 **추가적인 속성을 가지는 값도 여전히 그 타입**에 속한다.  
``` ts
const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
};  // OK
```
당연히 앞에 세 가지 보다 많은 속성을 가지는 값도 `PersonSpan` 타입에 속한다. 인터섹션 타입의 값은 각 타입 내의 속성을 모두 포함하는 것이 일반적인 규칙이다.  

하지만 두 인터페이스의 유니온에서는 그렇지 않다.  
``` ts
type K = keyof (Person | Lifespan);
//   ^? type K = never
```
앞의 유니온 타입에 속하는 값은 어떠한 키도 없기 때문에, 유니온에 대한 `keyof` 은 공집합(`never`) 여야만 한다.  

조금 더 일반적으로 `PersonSpan` 타입을 선언하는 방법은 `extends` 키워드를 쓰는 것이다.  
``` ts
interface Person {
  name: string;
}
interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

**서브타입**은 어떤 집합이 다른 집합의 부분 집합이라는 의미다.
``` ts
interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: number; }
```
위 코드에서 `Vector3D` 는 `Vector2D` 의 서브타입이고, `Vector2D` 는 `Vector1D` 의 서브타입이다. (클래스 관점에서 '서브클래스')  
``` ts
interface Vector1D { x: number; }
interface Vector2D { x: number; y: number; }
interface Vector3D { x: number; y: number; z: number; }
```
`extends` 없이 인터페이스로 코드를 작성해보면 부분집합, 서브타입, 할당 가능성의 관계가 바뀌지 않는다는 것을 명확히 알 수 있다.  

``` ts
function getKey<K extends string>(val: any, key: K) {
  // ...
}
```
위 코드에서 `string`을 상속한다는 의미를 객체 상속의 관점으로 생각한다면 이해하기 어렵지만, 집합의 관점으로서는 `string`의 부분 집합 범위를 가지는 어떠한 타입이 된다. 이는 `string` 리터럴 타입, `string` 리터럴 타입의 유니온, `string` 자신을 포함한다.
``` ts 
getKey({}, 'x');  // OK, 'x' extends string
getKey({}, Math.random() < 0.5 ? 'a' : 'b');  // OK, 'a'|'b' extends string
getKey({}, document.title);  // OK, string extends string
getKey({}, 12);
//         ~~ Type 'number' is not assignable to parameter of type 'string'
```

``` ts
interface Point {
	x: number;
	y: number;
}
type PointKeys = keyof Point; // 'x' | 'y'

function sortBy<K extends keyof T, T>(vals: T[]. key: K): T[] {
	// ...
}
const pts: Point[] = [{x: 1, y: 1}, {x: 2, y: 0}];
sortBy(pts, 'x'); // OK, 'x' extends 'x'|'y'
sortBy(pts, 'y'); // OK, 'y' extends 'x'|'y'
sortBy(pts, Math.random() < 0.5 ? 'x' : 'y'); // OK, 'x'|'y' extends 'x'|'y'
sortBy(pts, 'z');
//          ~~~ Type '"z"' is not assignable to parameter of type '"x" | "y"'
```

타입들이 엄격한 상속 관계가 아닐 때는 집합 스타일이 더욱 바람직하다.  
예를 들어, `string|number` 와 `string|Date` 사이의 인터섹션은 공집합이 아니며 `string` 이고, 서로의 부분 집합도 아니다. 이 타입들이 엄격한 상속 관계가 아니더라도 범위에 대한 관계는 명확하다.  

타입이 집합이라는 관점은 배열과 튜플의 관계 역시 명확히 만든다.  
``` ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
//    ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
//           Source has 3 element(s) but target allows only 2.
```
숫자의 배열은 숫자들의 쌍이라고 볼 수 없다. 그렇기 때문에 `number[]` 는 `[number, number]` 의 부분집합이 아니기 때문에 할당할 수 없다. (그 반대로는 동작한다.)  

세 숫자를 가지는 트리플은 구조적 타이핑의 관점으로 생각하면, 쌍으로 할당 가능할 것으로 생각된다. 상은 0번과 1번 키를 가지므로, 2번과 같은 다른 키를 가질 수 있는지 확인해보자.
``` ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
//    ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'
//           Source has 3 element(s) but target allows only 2.
```
오류가 발생했는데, 그 이유는 타입스크립트가 숫자의 쌍을 `{0: number, 1: number}` 로 모델링하지 않고, `{0: number, 1: number, length: 2}` 로 모델링했기에 길이의 차이가 생겨 오류가 발생했다. 쌍이라는 특성이 있기 떼문에 길이를 체크하는 합리적인 방식을 사용했다.  

타입이 값의 집합이라는 것은, **동일한 값의 집합을 가지는 두 타입은 같다**는 의미가 되며, 두 타입이 의미적으로 다르고 우연히 같은 범위를 가진다고 해도 같은 타입을 두 번 정의할 이유는 없다.  

한편, 타입스크립트 타입이 되지 못하는 값들의 집합도 존재한다. 정수에 대한 타입, 또는 x와 y 속성 외에 다른 속성이 없는 객체는 타입스크립트 타입에 존재하지 않는다. 가끔 `Exclude`를 사용해서 일부 타입을 제외할 수는 있지만, 그 결과가 적절한 타입스크립트 타입일 때만 유효하다.  
``` ts
type T = Exclude<string|Date, string|number>;
//   ^? type T = Date
type NonZeroNums = Exclude<number, 0>;
//   ^? type NonZeroNums = number
```

![타입스크립트 용어와 집합 용어](./아이템%207.%20타입이%20값들의%20집합이라고%20생각하기/image.png)

---
### 요약
* 타입을 값의 집합으로 생각하면 이해하기 편하다. 이 집합은 유한하거나 무한(`number` 또는 `string`)하다.
* 타입스크립트 타입은 엄격한 상속 관계가 아니라 벤 다이어그램으로 표현된다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.
* 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
* 타입 연산은 집합의 범위에 적용된다. `A`와 `B`의 인터섹션은 `A`의 범위와 `B`의 범위의 인터섹션이다. 객체 타입에서는 `A & B`인 값이 `A`와 `B`의 속성을 모두 가짐을 의미한다.
* 'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은 'A는 B의 부분집합'과 같은 의미를 가진다.