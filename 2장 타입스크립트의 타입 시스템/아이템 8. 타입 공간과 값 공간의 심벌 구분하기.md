## 타입 공간과 값 공간의 심벌 구분하기

타입스크립트의 심벌(symbol)은 타입 공간이나 값 공간 중의 한 곳에 존재한다.  
심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있다.  
``` ts
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({radius, height});
```

`interface Cylinder`에서 `Cylinder`는 타입으로 쓰인다. `const Cylinder`에서의 `Cylinder`는 이름은 같지만 값으로 쓰이며, 서로는 아무런 관련이 없다. 상황에 따라서 `Cylinder`는 타입으로도, 값으로도 쓰일 수 있다. 이러한 점이 오류를 야기한다.

``` ts
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
    //    ~~~~~~ Property 'radius' does not exist on type '{}'
  }
}
```
위 코드에서는, 아마도 `instanceof`를 사용해 `shape`가 `Cylinder` 타입인지 체크하려고 했을 것이지만, `instanceof`는 자바스크립트의 런타임 연산자이고, 값에 대한 연산을 하기 때문에 `instanceof Cylinder`는 타입이 아닌 함수를 참조한다.  

한 심벌이 타입인지 값인지는 언뜻 봐서 알 수 없기 때문에, 어떤 형태로 쓰이는지 문맥을 통해 알아내야 한다. 많은 타입 코드가 값 코드와 비슷하기 때문에 더욱 혼란스럽다.  
``` ts
type T1 = 'string literal';
const v1 = 'string literal';
type T2 = 123;
const v2 = 123;
```
일반적으로 `type`이나 `interface` 다음에 나오는 심벌은 타입인 반면, `const`나 `let` 선언 에 쓰이는 것은 값이다. 두 공간에 대한 개념을 잡으려면 [타입스크립트 플레이그라운드](https://www.typescriptlang.org/play/)를 활용하면 된다. 이는 타입스크립트 소스로부터 변환된 자바스크립트 결과물을 보요주고, 이 과정에서 타입 정보는 제거되기 때문에 타입 심벌을 구별할 수 있다.  

`class`와 `enum`은 상황에 따라 타입과 값 두 가지 모두 가능하다. 다음 예제애서 `Cylinder` 클래스는 타입으로 쓰였다.
``` ts
class Cylinder {
  radius: number;
  height: number;
  constructor(radius: number, height: number) {
    this.radius = radius;
    this.height = height;
  }
}

function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape
    // ^? (parameter) shape: Cylinder
    shape.radius
    //    ^? (property) Cylinder.radius: number
  }
}
```
클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면, 값으로 쓰일 때는 생성자가 사용된다.  
한편, 연산자 중에서도 타입에서 쓰일 때와 값에서 쓰일 때 다른 기능을 하는 것들이 있는데, 그 중 하나로 `typeof`를 들 수 있다.  
```ts
type T1 = typeof jane;
//   ^? type T1 = Person
type T2 = typeof email;
//   ^? type T2 = (to: Person, subject: string, body: string) => Response

const v1 = typeof jane;  // Value is "object"
const v2 = typeof email;  // Value is "function"
```
타입의 관점에서, `typeof`는 값을 읽어서 타입스크립트 타입을 반환한다. 타입 공간의 `typeof`는 보다 큰 타입의 일부분으로 사용할 수 있고, `type` 구문으로 이름을 붙이는 용도로도 사용할 수 있다.  
값의 관점에서, `typeof`는 자바스크립트 런타임의 `typeof` 연산자가 된다. 값 공간의 `typeof`는 대상 심벌의 **런타임 타입**을 가리키는 문자열을 반환하며, 타입스크립트 타입과는 다르다. 자바스크립트의 런타임 타입 시스템은 타입스크립트의 정적 타입 시스템보다 훨씬 간단하고, 지금까지 단 6개(`string`, `number`, `boolean`, `undefined`, `object`, `fuction`)의 런타임 타입만이 존재한다.
```ts
const v = typeof Cylinder; // 값이 "function"
type T = typeof Cylinder // 타입이 typeof Cylinder
```
두 번째 줄의 타입은 다음과 같이 사용될 수 있다. 여기서의 타입은 인스턴스의 타입이 아니라 생성자 함수이다. 이는 `InstanceType` 제너릭을 사용해 생성자 타입과 인스턴스 타입을 전환할 수 있다.  
``` ts
declare let fn: T;
const c = new fn(); // 타입이 Cylinder
```

속성접근자 `[]`는 타입으로 쓰일때도 동일하게 동작한다. 다만` obj['field']`와 `obj.field`는 동일한 값이지만 타입이 다를 수 있다. 정확한 타입을 얻기 위해서는 `obj['field']`를 사용해야 한다. 또한 인덱스 위치에는 어떠한 타입이든 사용할 수 있다.  
```ts
type PersonEl = Person['first' | 'last'];
//   ^? type PersonEl = string
type Tuple = [string, number, Date];
type TupleEl = Tuple[number];
//   ^? type TupleEl = string | number | Date
```

두 공간 사이에서 다른 의미를 가지는 코드 패턴들이 다음과 같이 존재한다.  

* `this`
  * 값: 자바스크립트의 this 키워드
  * 타입: **다형성(polymorphism) this**라고 불리는 타입스크립트의 `this`, 서브클래스 메서드 체인에 사용됨
* `&`, `|`
  * 값: 비트 AND, OR연산
  * 타입:인터섹션, 유니온
* `const`
  * `const`: 새 변수 선언
  * `as const`: 리터럴 또는 리터럴 표현식의 추론 타입 변경
* `extends`
  * 서브 클래스(`class A extends B`), 서브 타입(`interface A extends B`), 제너릭타입의 한정자 선언(`Generic<T extends number>`)에 사용
* `in`
  * 루프 또는 매핑된 타입에 사용

<br/>

타입스크립트 구조분해할당의 올바른 예시는 다음과 같다.  
``` ts
function email(
  {to, subject, body}: {to: Person, subject: string, body: string}
) {
  // ...
}
```

---
### 요약
* 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야 한다. 타입스크립트 플레이그라운드를 통해 개념을 잡는 것이 좋다.
* 모든 값을 타입을 가지지만, 타입은 값을 가지지 않는다. `type`과 `interface` 같은 키워드는 타입 공간에만 존재한다.
* `class`과 `enum`같은 키워드는 타입과 값 두 가지로 사용될 수 있다.
* `"foo"`는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있다. 차이점을 알고 구별하는 법을 터득해야 한다.
* `typeof`, `this` 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.