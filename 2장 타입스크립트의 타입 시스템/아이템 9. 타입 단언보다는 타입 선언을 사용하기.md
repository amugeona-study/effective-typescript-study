## 타입 단언보다는 타입 선언을 사용하기

타입스크립트에는 변수에 값을 할당하고 타입을 부여하는 두 가지 방법이 있다.  
```ts
interface Person { name: string };

const alice: Person = { name: 'Alice' };
//    ^? const alice: Person
const bob = { name: 'Bob' } as Person;
//    ^? const bob: Person
```
위의 방법은 **타입 선언**이며, 그 값이 선언된 타입임을 명시한다.  
아래의 방법은 **타입 단언**이며, 타입스크립트가 추론한 타입이 있더라도 해당 타입으로 간주한다.

이 두 가지 방법 중 타입 선언을 권장하며, 그 이유는 다음과 같다.  
```ts
const alice: Person = {};
//    ~~~~~ Property 'name' is missing in type '{}' but required in type 'Person'
const bob = {} as Person;  // No error
```
타입 선언은 할당되는 값에 대한 검사를 진행하지만, 타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 명령한다.  

이는 속성을 추가할 때에도 마찬가지다.  
```ts
const alice: Person = {
  name: 'Alice',
  occupation: 'TypeScript developer'
// ~~~~~~~~~ Object literal may only specify known properties,
//           and 'occupation' does not exist in type 'Person'
};
const bob = {
  name: 'Bob',
  occupation: 'JavaScript developer'
} as Person;  // No error
```
타입 단언이 꼭 필요한 경우가 아니라면 안정성 체크가 되는 타입 선언을 사용하는 것이 적절하다.  

화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 존재한다. 다음 코드를 보자.  
```ts
const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// { name: string; }[]... but we want Person[]
```
{name}에 타입 단언을 쓰면 문제가 해결되는 것처럼 보이나,  
```ts
const people = ['alice', 'bob', 'jan'].map(
  name => ({name} as Person)
); // Type is Person[]
```
타입 단언을 쓰면 런타임에 문제가 생길 소지가 존재한다.  
```ts
const people = ['alice', 'bob', 'jan'].map(name => ({} as Person));
// No error
```

따라서, 단언문을 쓰지 않고 다음과 같이 함수의 내부에서 타입을 가진 변수를 선언하는 것이 가장 직관적이다.  
```ts
const people = ['alice', 'bob', 'jan'].map(name => {
  const person: Person = {name};
  return person
}); // Type is Person[]

const people = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
); // Type is Person[]

const people: Person[] = ['alice', 'bob', 'jan'].map(name => ({name})); // OK
```

다만, 함수 호출 체이닝이 연속되는 곳에서는 체이닝의 시작부터 명명된 타입을 가져야 정확한 곳에 오류가 포함된다.  

<br/>

타입 단언은 타입 체커가 추론한 타입보다 우리가 판단하는 타입이 더 정확할 때 사용한다. 예를 들어, DOM을 사용할 때가 있다.
```ts
document.querySelector('#myButton')?.addEventListener('click', e => {
  e.currentTarget
  // ^? (property) Event.currentTarget: EventTarget | null
  // currentTarget is #myButton is a button element
  const button = e.currentTarget as HTMLButtonElement;
  //    ^? const button: HTMLButtonElement
});
```

타입스크립트는 DOM에 접근할 수 없기 때문에 `#myButton`이 버튼 엘리먼트인지 모른다. 그렇기 때문에 이때는 타입 단언을 쓰는 것이 더 정확하다.  

또한 `!`을 사용하여 null이 아님을 단언하는 경우도 존재한다.  
```ts
const el = document.getElementById('foo')!;
//    ^? const el: HTMLElement
```
접미사로 쓰인 `!`는 일반적인 단언문처럼 생각해야 한다. 단언문은 컴파일 과정 중에 제거되므로, 타입 체커는 알지 못하지만 그 값이 `null`이 아니라고 확신할 수 있을 때 사용해야 한다.  

타입 단언문으로 임의의 타입 간의 변환을 할 수는 없으며, A가 B의 부분집합인 경우에 타입 단언문을 사용해 변환할 수 있다.  
```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person;
//         ~~~~~~~~~~~~~~
// Conversion of type 'HTMLElement' to type 'Person' may be a mistake because
// neither type sufficiently overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first.
```
이 오류를 해결하기 위해서는 `unknown` 타입을 사용해야 한다. 모든 타입은 `unknown` 타입의 서브타입이기 때문에 `unknown`이 포함된 단언문은 항상 동작한다.  
```ts
const el = document.body as unknown as Person;  // OK
```

---
### 요약
* 타입 단언(`as Type`)보다 타입 선언(`: Type`)을 사용해야 한다.
* 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
* 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 `not null` 단언문을 사용하면 된다.